# -*- coding: utf-8 -*-
"""Fibonacci-various.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1joOtLdaavZ_vDUoxtxHy0htErBU5Fi2Z
"""

from time import process_time

def callFn(fn, n):
    """
    Run fn(n).
    Print the result, the time, and the number of function_calls, which must be an attribute of fn.
    """
    
    fnName = fn.__name__ 
    print(f'\nStarting {fnName}({n})')
    startProc = process_time()
    fn_result = fn(n)
    endProc = process_time()
    function_calls = fn.function_calls
    # Once we retrieve the count of function calls, reset it to 0.
    fn.function_calls = 0
    print(f'{fnName}({n}) = {fn_result:,} in {function_calls:,} function calls. {round(endProc - startProc, 3)} seconds.')
    return fn_result



""" 
The first 50 Fibonacci numbers. (Generated at the end.)
(1) 1; (2) 1; (3) 2; (4) 3; (5) 5
(6) 8; (7) 13; (8) 21; (9) 34; (10) 55
(11) 89; (12) 144; (13) 233; (14) 377; (15) 610
(16) 987; (17) 1,597; (18) 2,584; (19) 4,181; (20) 6,765
(21) 10,946; (22) 17,711; (23) 28,657; (24) 46,368; (25) 75,025
(26) 121,393; (27) 196,418; (28) 317,811; (29) 514,229; (30) 832,040
(31) 1,346,269; (32) 2,178,309; (33) 3,524,578; (34) 5,702,887; (35) 9,227,465
(36) 14,930,352; (37) 24,157,817; (38) 39,088,169; (39) 63,245,986; (40) 102,334,155
(41) 165,580,141; (42) 267,914,296; (43) 433,494,437; (44) 701,408,733; (45) 1,134,903,170
(46) 1,836,311,903; (47) 2,971,215,073; (48) 4,807,526,976; (49) 7,778,742,049; (50) 12,586,269,025

"""


n = 32

from functools import wraps

def count_calls(function):

    @wraps(function)
    def wrapper(n):     
        wrapper.function_calls += 1
        return function(n)
       
    wrapper.function_calls = 0
#     wrapper.__name__ = function.__name__
    return wrapper

@count_calls
def fib_top_down_rec(n):
    """
    Traditional (naive) recursive Fibonacci algorithm.
    """
    result = 1 if n <= 2 else fib_top_down_rec(n-1) + fib_top_down_rec(n-2)
    return result 

callFn(fib_top_down_rec, n)

def fib_bottom_up_iter(n):
    kb = 0
    ka = 1
    c = 1
    fib_bottom_up_iter.function_calls = 0
    # Treat each time around the loop as a function call.
    while c < n:
        (c, ka, kb, fib_bottom_up_iter.function_calls) = (c+1, ka+kb, ka, fib_bottom_up_iter.function_calls+1)
    return ka

callFn(fib_bottom_up_iter, n)

class Fib:
    
    def __init__(self, arg):
        self.arg = arg
        
    # Not needed for the Fibonacci computation.    
    def __call__(self): 
        return fib_bottom_up_iter(self.arg) 

    def __str__(self):
        return f'Fib({self.arg})'
        
fib = Fib(6)
print(f'{Fib(6)} = {fib()}')

def printInpAndStack(inp, stack):
    print('[' + ','.join([str(token) for token in inp]) + ']', stack)

def fib_top_down_iter(n, trace=False):
    """
    Traditional (naive) Fibonacci algorithm in a while-loop, i.e., without recursion.
    Uses two stacks. Can be traced.
    """

    (inp, stack) = ([Fib(n)], [])
    fib_top_down_iter.function_calls = 0
    if trace: 
        printInpAndStack(inp, stack)
    
    while inp:
            
        token = inp.pop(-1)

        if isinstance(token, int):
            stack = [token] + stack
            
        elif isinstance(token, Fib):
            n = token.arg
            fib_top_down_iter.function_calls += 1
            if n <= 2:
                inp = inp + [1]
            else:
                inp = inp + ['+', Fib(n - 1), Fib(n - 2)]
                
        elif token == '+':
            (n1, n2, stack) = (stack[0], stack[1], stack[2:])
            inp = inp + [n1 + n2]
            
        else:
            raise Exception()
            
        if trace: 
            printInpAndStack(inp, stack)
    return stack[0]


print(f'Trace fib_top_down_iter(6)\n')
fib_top_down_iter(6, trace=True)

callFn(fib_top_down_iter, n)

def fib_top_down_iter_with_opt_1(n, trace=False):
    """
    Same as fib_top_down_iter but with more efficient list processing.
    Expands second recursive call down to the bottom.
    """
    (inp, stack) = ([Fib( n)], [])
    fib_top_down_iter_with_opt_1.function_calls = 0
    if trace: 
        printInpAndStack(inp, stack)
    
    while inp:
        token = inp.pop(-1)
        if isinstance(token, int):
            stack.insert(0, token)
            
            
        elif isinstance(token, Fib):
            n = token.arg
            fib_top_down_iter_with_opt_1.function_calls += 1
            
#           inp += ['+', Fib(n-1), Fib(n-2)]
#               += ['+', Fib(n-1), '+', Fib(n-3), Fib(n-4)]
#               += ['+', Fib(n-1), '+', Fib(n-3), '+', Fib(n-5), Fib(n-6)]
#               += ['+', Fib(n-1), '+', Fib(n-3), '+', Fib(n-5), ... Fib(3),  Fib(2)]
                        
            for k in range(n, 2, -2):
                fib_top_down_iter_with_opt_1.function_calls += 1                
                inp += ['+', Fib(k-1)]
            
            stack.insert(0, 1)
            
        elif token == '+':
            stack[0] = stack.pop(0) + stack[0]
            
        else:
            raise Exception(f'Bad input token: {token}')
            
        if trace:
            printInpAndStack(inp, stack)            
    return stack[0]

print(f'Trace fib_top_down_iter_with_opt_1(6)\n')
fib_top_down_iter_with_opt_1(8, trace=True)

callFn(fib_top_down_iter_with_opt_1, n)

def fib_top_down_iter_with_opt_2(n, trace=False):

    """
    Same as fib_top_down_iter but with more efficient list processing.
    Expands the first recursive call and groups results.
    Since this approach need keep track only of the n it is up to and 
    the coefficients of n-1 and n-2, it does so directly in a tuple.
    The result is equivalent to buttom-up iter.

           [ ..., 'fib'] [n] -> [Fib(n]
                             -> ['+', Fib(n-1), Fib(n-2)]
                             -> ['+', '+', Fib(n-2), Fib(n-3), Fib(n-2)]
                             -> ['+', '+', Fib(n-2), Fib(n-2), Fib(n-3]
                             -> ['+', '+', '*', 2, Fib(n-2), Fib(n-3]
                             -> ['+', '+', '*', 2, '+', Fib(n-3), Fib(n-4), Fib(n-3)]
                             -> ['+', '+', '+', '*', 3, Fib(n-3), '*', 2, Fib(n-4)]
                             -> ['+', '+', '+', '*', 5, Fib(n-4), '*', 3, Fib(n-5)]
                             -> ['+', '+', '+', '*', 8, Fib(n-5), '*', 5, Fib(n-6)]
                             -> ...
                             -> ['+', '+', ..., '+', '*', fn-1, 1, '*', fn-2, 1]
                             -> ['+', '+', ..., '+', fn-1, fn-2]
    """
    fib_top_down_iter_with_opt_2.function_calls = 0
    state = (n, 1, 0)
    
    while True:
        fib_top_down_iter_with_opt_2.function_calls += 1
        (n, ka, kb) = state
        state = (n-1, ka+kb, ka)
        if n <= 2:
            break
    (_, ka, _) = state           
    return ka

callFn(fib_top_down_iter_with_opt_2, n)

def fib_top_down_iter_with_cache(n, trace=False):
    """
    Traditional (naive) Fibonacci algorithm in a while-loop and with result caching.
    """
    fibDict = {1:1, 2: 1}
    (inp, stack) = ([Fib(n)], [])
    fib_top_down_iter_with_cache.function_calls = 0
    if trace: 
        printInpAndStack(inp, stack)
    
    while inp:

        token = inp.pop(-1)
        
        if isinstance(token, int):
            stack = [token] + stack
            
        elif isinstance(token, Fib):
            n = token.arg
            fib_top_down_iter_with_cache.function_calls += 1
            if n in fibDict:
                inp = inp + [fibDict[n]]
            else:
                inp = inp + ['cache', n, '+', Fib(n - 1), Fib(n - 2)]
                
        elif token == '+':
            (n1, n2, stack) = (stack[0], stack[1], stack[2:])
            inp = inp + [n1 + n2]
            
        elif token == 'cache':
            (n1, n2, stack) = (stack[0], stack[1], stack[1:])
            fibDict[n1] = n2
            
        else:
            raise Exception()
            
        if trace:
            printInpAndStack(inp, stack)            
    return stack[0]


print(f'Trace fib_top_down_iter_with_cache(6)\n')
fib_top_down_iter_with_cache(8, trace=True)

callFn(fib_top_down_iter_with_cache, n)

from functools import wraps

def memoize(function):

    @wraps(function)
    def wrapper(n):       
        if n not in wrapper.cache:
            wrapper.cache[n] = function(n)
        return wrapper.cache[n]
       
    wrapper.cache = {}
    return wrapper

@count_calls
@memoize
def fib_top_down_rec_with_cache(x):
    result = 1 if x <= 2 else fib_top_down_rec_with_cache(x-1) + fib_top_down_rec_with_cache(x-2)
    return result

callFn(fib_top_down_rec_with_cache, n)

def genFibTable(n):

    # Note that because the cache is reused, this makes calls only for new values of n.
    print(f'len(fib_top_down_rec_with_cache.cache): {len(fib_top_down_rec_with_cache.cache)}')
    callFn(fib_top_down_rec_with_cache, n)  # The cache now has all the Fibonacci numbers up to n.
    print(f'len(fib_top_down_rec_with_cache.cache): {len(fib_top_down_rec_with_cache.cache)}\n\n')

    # Extract and sort the cache.
    fibCacheSorted = sorted(fib_top_down_rec_with_cache.cache.items()) 
       # => [(1, 1), (2, 1), (3, 2), (4, 3), (5, 5), (6, 8), (7, 13), ...]

    # Convert each tuple to a string, with the Fibonacci number formatted with commas -- the ":," part.
    fibCacheStrings = [f'({n}) {fibn:,}' for (n, fibn) in fibCacheSorted] 
       # => ['(1) 1', '(2) 1', '(3) 2', '(4) 3', '(5) 5', '(6) 8', '(7) 13', ...]

    # Group the strings into lists of 5 each.
    from math import ceil
    fibRows = [fibCacheStrings[5*i : 5*i+5] for i in range(ceil(n/5))]
       # => [['(1) 1', '(2) 1', '(3) 2', '(4) 3', '(5) 5'], ['(6) 8', '(7) 13', ...], ...]

    for row in fibRows:
        print(*row, sep='; ', end=';\n')

#   Alternatively, use join() to convert each row into a single string.
#     # Convert each list to a single string with the elements separated by "; ".
#     fibRowStrings = ['; '.join(row) for row in fibRows]
#        # => ['(1) 1; (2) 1; (3) 2; (4) 3; (5) 5', '(6) 8; (7) 13; ...',  ...]

#     for row in fibRowStrings:
#         print(row, end=';\n')

genFibTable(50)